ПРОСТОЙ МОДУЛЬ ДЛЯ ВЫКАЧИВАНИЯ ФАЙЛОВ С КОМПЬЮТЕРА
ТЕХНИЧЕСКОЕ ЗАДАНИЕ

Назначение программы - поиск и выкачивание данных с компьютера
Название проекта pwuploader

ОПИСАНИЕ И ОФОРМЛЕНИЕ

Программа должна быть оформлена как .exe-файл, не принимающий параметров с командной строки.

1. Программа ищет файлы по ключевым словам, интеллектуальным поиском Windows (который F3 в Проводнике).
Список ключевых слов захардкожен в программе.
  
2. Все найденные файлы отправляем по протоколу отправки файлов.
3. Для получения собственного ID, читаем переменную окружения PROMPT.
В этой переменной будет находиться не обычное для DOS/Windows приглашение командной строки,
а данные идентификации программы.

Парсим строку по разделителю , (запятая) на три части:
- Client ID
- Group ID
- IP address
Если строка не парсится (полей больше или меньше), или адрес не похож на адрес, принимаем значения этих полей за:
Client ID: %MACHINE%-%USER%_W%winver%.%hex32% (генерируем по схеме, обозначенной ниже)
Group ID: nop000
IP address: 0.0.0.0

Id клиента - это строка, состоящая из двух компонентов разделённых точкой.
Первая часть имеет формат %MACHINE%-%USER%_XYYYYYYY, где
MACHINE - имя компьютера
USER - имя юзера
X - символ обозначающий тип системы на которой работает клиент
(W - windows, L - linux, A - андроид, M - Mac OS),
YYYYYYY - 3-7 цифр содержащих major-version, minor-version и build операционной системы если таковые имеются у систем
(например, длЯ 6.1 build 7600 это будет 617600).
Вторая часть содержит 32 случайных символов 0-9, A-F.
Пример id клиента - HOSTNAME-USER_W617600.11223344556677889900AABBCCDDEEFF.
Параметр не чувствителен к регистру.
4. При передаче данных по сети (протокол HTTP), все HTTP-коды, не начинающиеся с 200, являются ошибкой.
При проблеме передачи (код не-200 или отсутствие ответа) делаем десятикратный повтор попыток с таймаутом в час и умираем.
5. Адрес сервера зашивается в программе.
Программа должна уметь работать как по HTTP, так и по HTTPS - для этого можно использовать функции WinInet/WinHTTP.
6. Программа должна удалить себя с диска после завершения.


ОФОРМЛЕНИЕ МОДУЛЯ
1. Если выбран компилятор Microsoft, то должен иметься проект Microsoft Visual Studio версии не ниже 2015.
2. Проект Visual Studio должен быть настроен следующим образом:
* Для ВСЕХ профилей сборки:
- выходной каталог: $(SolutionDir)Bin\$(PlatformTarget)\$(Configuration)\
- Промежуточный каталог: $(SolutionDir)\obj\$(Platform)\$(Configuration)\$(ProjectName)\
- Многопроцессорная компиляция: да
* Профиль Release:
- Формат отладочной информации (С/С++ создание кода): нет
- Создавать отладочную информацию (компоновщик/отладка): нет
3. Строки обфусцировать библиотекой Andrivet (приложена, см.макрос _STR())
4. Системные вызовы обфусцировать библиотекой GetApi.h. Быть внимательным, обфускация сисвызовов может давать падения.
5. Модуль должен иметь две версии - x32- и x64-разрядную.
6. В боевой сборке должны быть обфусцированы по максимуму строки, отключен всяческий отладочный вывод.
7. Модуль должен иметь отладочную версию. Отладочный вывод должен выводиться в modulename.log (путь к логу настраивается в макросе).
Каждая запись лога должна содержать временнУю метку с точностью до секунды.
8. В проекте должен быть файл настроек config.h (название неважно, важна суть - здесь все глобальные настройки - пути, макросы-переключатели условной компиляции итд).
9. Модуль должен работать на всех современных версиях Windows.
   Минимальная поддерживаемая версия Windows - Windows XP (если невозможно - Windows Vista).
10. Дополнительно к компоновке должен добавляться файл notelemetry.obj (https://stackoverflow.com/questions/37761768/how-to-prevent-visual-studio-2015-update-2-to-add-telemetry-main-invoke-trigger)


ПРОТОКОЛ ПЕРЕДАЧИ ФАЙЛОВ

1) на сервер отправляется основная информация о компьютере через HTTP POST в контейнере multipart/form-data (аналогично обычной отправке html-формы).
POST содержит следующие поля:
timestamp - локальное UNIX-время
ip        - поле IP address
ip1       - адрес первого сетевого интерфейса (в данной реализации поля с локальными адресами интерфейсов не используются; зарезервировано)
ip2       - адрес второго сетевого интерфейса
...
ipN       - адрес N-го сетевого интерфейса
cid       - поле Client ID
group     - поле Group ID
hostname  - имя хоста, полученное через GetComputerName()
source    - строка `pw'

Отправка происходит на url вида:
http://foo.com/<junk>/<auth>/<junk>
junk - произвольные символы, допустимые в URI, кроме слеша /
auth - авторизующая секция. Предполагается, что тот кто отправляет запрос,
должен знать правила формирования этой секции.
Это - рандом любой длины. 
В ней обязательны:
- буква Z в любой позиции 
- сумма цифр (не чисел!) с 6 по 15-ю позицию должна быть 31. 
Символы между ними - рандом. В частности там может находиться и Z.
Пример секции - abcde7ol7k9hi8mZ

2) далее отправляется каждый файл по частям, запросом HTTP POST, в контейнере multipart/form-data.
Файл передается в поле file.
Имя файла берется из тега Content-Disposition; имя временного файла из URI игнорируется.
При этом:
- отправка файла начинается с конца. К примеру, если файл длиной 100М, мы отправляем последние 10М файла.
- после отправки куска файла и получения подтверждения, программа запоминает состояние, и отправляет следующий кусок.
- перед отправкой, отправляемый кусок файла читается в память и сжимается алгоритмом gzip.
- отправка производится на URL вида
junk - произвольные символы, допустимые в URI, кроме слеша /
auth - авторизующая секция. Это - рандом любой длины, в котором обязательны
- буква S в любой позиции
- сумма цифр (не чисел!) с 8 по 15-ю позицию должна быть 25. 
cid      - поле Client ID
filename - имя файла в кодировке URL Encoded;
start - начальное смещение передаваемого куска относительно начала файла; здесь допустимы и буквы, и цифры.
Но значащими являются только цифры, в порядке появления в строке.
Например, 0A -- это число 0 (цифра 0 значащая, буква A игнорируется).
end - конечное смещение передаваемого куска относительно начала файла; правила те же, что и для start.
Например, 3A5A2A3A9A5A9A - это 3523959.
eof - признак конца файла. Если признак есть, это последний кусок файла; и наоборот (секция необязательная)
Это рандом любой длины, в котором обязательны:
- первая цифра чётная или 0
- последняя буква A или F 

При обработке ошибок, код HTTP-ответа 200 не говорит об успехе операции,
но код не-200 говорит о неуспехе операции (например, 50* или 40* от прокси).
Точный код операции содержится внутри XML в теле HTTP-ответа, внутри тега <response>.
При получении кода ответа вида 4041, добавочный символ 1 - это внутренний код ошибки сервера (включен только во время отладки).

Например, следующий ответ свидетельствует об ошибке с кодом 9:

HTTP/1.1 200 OK
Server: nginx/1.10.3 (Ubuntu)
Date: Mon, 07 Oct 2019 13:08:44 GMT
Content-Type: application/xml; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept

<?xml version="1.0" encoding="UTF-8"?>
<response>4049</response>

Следующий ответ - ошибки нету, все ок
HTTP/1.1 200 OK
Server: nginx/1.10.3 (Ubuntu)
Date: Mon, 07 Oct 2019 13:08:44 GMT
Content-Type: application/xml; charset=UTF-8
Transfer-Encoding: chunked
Connection: keep-alive
Vary: Accept

<?xml version="1.0" encoding="UTF-8"?>
<response>200</response>
