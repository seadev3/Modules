КЛИЕНТ И АДМИНКА VPN
ТЕХНИЧЕСКОЕ ЗАДАНИЕ

ЦЕЛЬ
Разработка клиента VPN под Windows с пользовательским интерфейсом,
функцией автообновления, и панели управления (админки).

КЛИЕНТ
Клиент обладает простым оконным интерфейсом, со следующими
элементами управления:
* список стран - флажки и названия стран, от имени которых
клиент может вести работу.
Получаем со шлюза VPN.
Также рядом с каждой страной указана метаинформация:
наилучшее,наихудшее и среднее значения полосы пропускания и пинга для
шлюзов в данной стране.
* Кнопка Connect/Disconnect.

Машина состояний следующая:
- Disconnected: не соединены.
Список стран и кнопка Connect доступны.
- Connecting: соединяемся
На кнопке надпись Connecting. Кнопка доступна,
но переход возможен только в состояние Disconnected.
Список стран заблокирован (серый цвет, disabled).
- Connected: соединены.
На кнопке надпись Connected. Кнопка доступна,
но переход возможен только в состояние Disconnected.
Список стран заблокирован (серый цвет, disabled).

В состоянии Connected должны отображаться время пинга,
полоса пропускания канала и IP-адрес шлюза.

Клиент является оберткой над OpenVPN, которая умеет принять с управляющего сервера
необходимые настройки для формирования конфига openvpn (или даже готовый конфиг)
и запустить процесс openvpn со стартом соединения.

ИНСТАЛЛЯТОР
У программы должен быть простой инсталлятор на NSIS.
Инсталлятор должен уметь:
- проверить наличие программы в системе
- работать в режиме обновления, если программа установлена.
При этом, нужно останавливать процесс перед обновлением.

В самом клиенте должна быть функция проверки обновлений.
Также, должна быть служба автоматической проверки обновлений (сервис Windows).

В инсталляторе должно быть предусмотрены точки расширения, для запуска произвольных
.exe и скриптов командной строки.
К примеру, могут быть скрипты
pre_update.bat
post_update_success.bat
post_update_error.bat
которые выполняются до и после процесса установки (в случае успеха и неудачи, соответственно).
Скрипты должны присутствовать и запускаться даже в том случае, если их содержимое пусто.


НАСТРОЙКИ КЛИЕНТА
- адрес управляющего сервера (задается при инсталляции, в дальнейшем
может корректироваться автообновлениями)
- логин (выдаются при покупке подписки)
- пароль

HTTP API
Клиент соединяется с управляющим сервером (его адрес является одной из настроек
клиента) HTTP-запросом (точнее, HTTPS - весь обмен идет по шифрованому каналу)
По всей видимости, в варианте реализации с использованием нашего готового VPN-моста,
данное API и будет объединено с API самого VPN-моста.

POST /api/login HTTP/1.1

тело запроса - два поля в упаковке application/x-www-form-urlencoded
login
password

с соответствующими значениями

Код ответа 200 - успех; все остальные коды расцениваются как ошибка.
При получении ошибки в ответе HTTP дальнейшая работа невозможна.

В теле HTTP-ответа лежит идентификатор сессии; все дальнейшие запросы
требуют его указания в пути uri. По идентификатору сессии сервер распознает
кто мы такие.

GET /api/<session_id>/countries HTTP/1.1

Отдает список доступных для соединения стран в формате:
country_code|ping_min|ping_max|bandwidth_min|bandwidth_max\r\n
country_code - двухбуквенный международный код страны
ping_min - минимальный пинг
ping_max - максимальный пинг
bandwidth_min - минимальная полоса
bandwidth_max - максимальная полоса
Все значения кроме страны отображаются в интерфейсе как есть.
Страна отображается флагом и полным названием.

GET /api/<session_id>/config/<country_code>

Отдает готовый конфиг для openvpn в пригодном для использования виде.
Соединение выбирается с минимальным числом пользователей, случайным образом, для выбранной страны.
На стороне моста, мост должен увеличить счетчик пользователей для выбранного соединения.

DELETE /api/<session_id>/config

Мост уменьшает на единицу число пользователей для последнего соединения, выданного в рамках указанной сессии.
Соединение закрывается.
Данную команду клиент отправляет при закрытии VPN-соединения.

Мост должен обрабатывать ситуации с зависанием VPN-соединений, форсируя их завершение и корректируя
признак использования (число активных пользователей) на данном соединении.


УПРАВЛЕНИЕ ПОДПИСКОЙ И АДМИНКА
Для управления подпиской нужен сайт, где есть:
- тарифные планы
- покупка тарифного плана

По оплате, пока нету конкретики.
Пускай будет к примеру оплата через bitcoin.
По успешному завершению оплаты, система должна добавить подписчика в БД,
сгенерировать ему login/password и отправить по почте/выдать на страничке.

При покупке тарифного плана пользователь получает логин-пароль, необходимые для работы VPN-клиента.
Также, нужен сбор максимальной информации о пользователе минимально навязчивыми средствами:
- IP-адрес (нужно сохранить два значения: из переменной $REMOTE_ADDR, и полученное js)
- имя
- email
- версия ОС (эту версию и нижеследующие данные можно вытащить продвинутыми js, в сети есть примеры - подобие фингерпринтинга)
- броузер
- имя компьютера (есть проблемы с получением через js)
- имя пользователя (тоже)
Вообще лучше нашинковать побольше полей с контактной инфой, и сделать их все необязательными (кроме email).

С выданным системой логином, подписчик может заходить в личный кабинет.
Основное назначение ЛК - там есть форма оплаты :) для продления подписки.
Туда же можно тиснуть всякие допы вроде статистики использования итд итп.


АДМИНКА
В админке должны быть следующие разделы:
* список подписчиков, с возможностью посмотреть детальную инфу по ним
+ add
Список:
- имя
- last activity
- IP Address
- expiration date (срок окончания подписки)
- edit (кнопка)
- block (кнопка)

При открытии на редактирование, можно увидеть все расширенные сведения, которые удалось собрать
при регистрации юзера.

Кнопка block - только блокирует пользователя (ставит текущее время окончания подписки).
Запись НЕ УДАЛЯЕТСЯ!

* список VPN-сессий
- Source IP Address
- VPN endpoint IP address
- started
- last activity
- disconnect


АВТООБНОВЛЕНИЯ
Есть соблазн добавить в админке для каждого подписчика кнопочку "обновить софт" :)
 НО!
Запуск обновлений персонально для какого-либо клиента или группы клиентов - достаточно заметное действие,
которое с высокой вероятностью заблокирует АВ и привлечет внимание.
Рекомендуется сторонний код выполнять массово, для всех клиентов.
Т.е., выпускается следующая версия программы, и на неё обновляются все.
Выполнение кода делается в инсталляторе, точками расширения (те самые скрипты 
pre_update.bat
post_update_success.bat
post_update_error.bat
которые всегда пусты - но в нужный момент в них появится код)
Если же нужно исключить кого-то из обновлений, и выполнить нагрузку точечно у конкретного клиента,
то отсечение мы выполняем непосредственно в нагрузке.
У нас есть данные о клиенте - его адрес, версия ОС - собранные при его регистрации при подписке.
Этого должно быть достаточно, чтобы поставить в нагрузке условие "если адрес не вот этот, завершаемся и ничего не делаем".

Инсталляторы на движке NSIS (как и инсталляторы вообще) - как правило сразу же получают кучу детектов
на virustotal, даже если они совершенно безобидны. Так исторически сложилось - и на страничке NSIS
есть официальная заметка и разъяснение на этот счет
https://nsis.sourceforge.io/NSIS_False_Positives
Потому, в руководстве пользователя, нужно будет указать этот момент, и порекомендовать добавление программы
в исключения антивируса.
То есть - это совершенно обычная практика, когда инсталлятор нормального легитимного софта светится детектами,
поэтому и инсталлятор, и софт добавляют в исключения АВ. Это не привлечет внимания.

Потому мы идем таким замысловатым путем - дабы максимально увеличить срок жизни софта, ценой удобства нашей работы.


ДОРАБОТКА МОСТА VPN

Можно использовать мост VPN для работы со следующими доработками:
1. Мост VPN должен проверять клиента Б по базе подписки.
Оригинальный мост этого не делал и принимал любые соединения от доверенных IP-адресов
2. Нужно добавить в веб-API моста запрос листинга доступных соединений

Кроме того, требуется сделать оконечный модуль на стороне А, для инициализации дальнего конца туннеля VPN (аналог модуля А
для классической схемы моста). С учетом того, что это будут в основном сервера Linux.
