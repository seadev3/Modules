СКАНЕР ФАЙЛОВ НА РЕСУРСАХ С ИЗВЕСТНЫМИ ПАРОЛЯМИ
ТЕХНИЧЕСКОЕ ЗАДАНИЕ

ОПИСАНИЕ ИДЕИ
На входе у нас есть список доступа вида
ssh://user:pass@host:port
ftp://user:pass@host:port

Нужно отфильтровать только те сервера, на которых есть удовлетворяющие маске файлы.

ТРЕБОВАНИЯ К СОФТУ
Программа оформляется как модуль в соответствии с документами module_HOWTO и
"оформление кода и сборок".

Название проекта: fscan

Модуль отправляет следующие события с тегом fscan:
- "Version build %DATE% %TIME%" (один раз при старте)
- "File found: %filename% at %user%@%server%:%port%" - когда найден файл по маске
- "Results sent to server" при успешной отправке найденных совпадений
- "No result detected, give up", если закончена отработка модуля и ничего не найдено (гипотетический случай)
В таком случае, модуль должен выдать событие WantRelease (см "module_HOWTO") для выгрузки из памяти


КОНФИГИ

Имя конфига - это аргумент Ctl функции Control, содержимое конфига - это аргумент CtlArg (см. modules_HOWTO.txt)

Конфиги должны быть в любой однобайтной кодировке (предпочтительно ASCII).
Модуль принимает единственный конфиг fsrv, содержащий список адресов управляющего сервера,
разделенных \r\n или \n, в формате адрес:порт.
Если порт четный, работа идет по HTTP, если нечетный - HTTPS.
Если указан префикс протокола (http/https), префикс имеет приоритет над указанным портом.
Модуль работает с тем управляющим сервером, до которого удалось достучаться первым, по каждому запросу.

РАБОТА С КОМАНДНЫМ СЕРВЕРОМ

Модуль общается с командным сервером по протоколу HTTP(s) простыми запросами.

Число потоков сканирования:
GET /<group>/<clientid>/fscan/th HTTP/1.1
Значения group и clientid - это поля struct ParentInfo
 CHAR ParentID[256];
 CHAR ParentGroup[64];
(см. module_HOWTO)
В ответ - неотрицательное число.
Если atoi(ответ) == 0, то число потоков по умолчанию = std::thread_concurrency() - 1.

Сканер получает список для сканирования HTTP-запросом на сервер

GET /<group>/<clientid>/fscan/domains HTTP/1.1
Формат ответа:
proto://user:pass@host[:port][\r]\n
...
(одна или множество записей)

Сканер получает список регулярных выражений для поиска запросом
GET /<group>/<clientid>/fscan/rules HTTP/1.1
Формат ответа:
regexp1[\r]\n
regexp2[\r]\n
...
(одна или множество записей)

При сканировании, сканер ищет ЛЮБОЙ файл подходящий под регулярку.
При этом, после нахождения файла сканирование продолжается.

Сканер получает стартовый каталог для поиска запросом
GET /<group>/<clientid>/fscan/home HTTP/1.1
Формат ответа:
path1[\r]\n
path2[\r]\n
...
(одна или множество записей)
Это каталоги, в которых нужно производить поиск.
Если каталогов несколько, поиск нужно производить в каждом из них.
Если ответ пуст, нужно искать в текущем каталоге.

Сканер получает глубину поиска запросом
GET /<group>/<clientid>/fscan/nest HTTP/1.1
Формат ответа:
неотрицательное целое число меньше 100.
Если ответ не подходит под это правило, глубина по умолчанию 10.
Число 0 означает отсутствие ограничений на глубину поиска.


При завершении перебора по выданному списку мы даем знать об этом серверу:

GET /<group>/<clientid>/fscan/over HTTP/1.1

Ответ сервера - такой же, как на запрос /domains - новый список доменов для работы.
При неожиданном ответе (пустой список, код ошибки итд) модуль переходит на холостой ход (сканирование остановлено)
и делает тот же самый запрос раз в 10 минут (время - в константу).

Отправка результатов делается по протоколу DPOST (см. "ТЗ граб паролей DPOST" для описания протокола) запросом

 POST /<group>/<clientid>/fscan/81 HTTP/1.1

Собранные данные отправляются в контейнере multipart/form-data с полями source и data.
Значение поля source - "Files found"
Значение поля data: простой текст, разделитель строк \r\n
Формат записи:

proto://user:pass@host:port/path/to/file\r\n
...
(одна или множество записей)

Частоту отправки намайненных данных можно получить с управляющего сервера HTTP-запросом
GET /<group>/<clientid>/fscan/freq HTTP/1.1

В теле ответа мы ожидаем число - это число секунд, не чаще которого следует отправлять данные.
Если это 0 - отправка сразу по готовности нового результата.
Если это положительное число - мы накапливаем записи в буфере и отправляем раз в X секунд,
очищая буфер при успешной отправке.


РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ

Используется свой собственный синтаксис регулярок.
Выражение может содержать символы звёздочка, вопросительный знак и квадратные скобки "[]".
* Звёздочка обозначает любую последовательность символов включая пустую
? Вопросительный знак обозначает любой одиночный символ
[] Квадратные скобки перечисляют список одиночных символов, например,
  [jeu] - на его месте может стоять только один из трёх символов "j" , "e" или "u",
  [?] - только символ вопросительного знака,
  [[] - только открывающая квадратная скобка,
  [*] - только символ звёздочка,
  [[*] - звёздочка или открывающая квадратная скобка.
Пример:   q[abc]erty[?]u[[]uu??88]88*
qaerty?u[uuzz88]88444 - подходит
qbertysu[uuzz88]88444 - не подходит
qcerty?u[uuz88]88 - не подходит
qaerty?u[uuz?88]88 - подходит
qrerty?u[uuz?88]88 -  не подходит
qaerty?u!uuz?88]8811 -  не подходит
