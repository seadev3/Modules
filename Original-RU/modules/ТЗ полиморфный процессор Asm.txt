ТЕХНИЧЕСКОЕ ЗАДАНИЕ
ПРЕПРОЦЕССОР ДЛЯ ПОЛИМОРФИРОВАНИЯ АССЕМБЛЕРНОГО КОДА

ЦЕЛЬ

Разработать препроцессор, который на вход получает Asm-листинг и на выход выдает также Asm-листинг,
в котором код эквивалентен исходному, но отличается по инструкциям, а также возможно другим критериям.

ТРЕБОВАНИЯ

Препроцессор должен быть выполнен в виде утилиты командной строки.
Ввод-вывод на усмотрение разработчика:
- читаем из stdin и результат пишем в stdout
- ключи командной строки откуда взять файл и в какой положить ответ
- комбинация 1 и 2

Должна быть краткая справка из самой утилиты, и развернутое readme на русском с описанием программы и ее режимами.

Любую эвристику можно включить и отключить ключами командной строки.
На любую эвристику должны быть граничные условия ее применения - т.е. рекомендации,
в каких случаях она безопасна, а в каких нет.
По умолчанию должны быть включены лишь безопасные эвристики.

Препроцессор должен понимать диалект ассемблера Microsoft Visual Studio 2010.
Должен работать как с 32-разрядными инструкциями, так и с 64-разрядными.

При необходимости использовать компиляторы, трансляторы и прочие инструменты, нужно предусмотреть отвязку
от конкретных вендоров и версий. Если нужно запускать транслятор, это должно быть сделано точками расширения.

Но вообще предполагается, что препроцессор будет сам включен в одно из событий сборки Visual Studio.


РЕАЛИЗАЦИЯ

Задача во многом исследовательская, и готовых рецептов нет.
Можно предложить следующие замены:
- дополнение и разбавление кода шумом (ничего не делающими многозначительными инструкциями)
- релокация адресов, не требующих релокации (либо внесение дополнительного смещения в адресацию
путем добавления паразитных байтов в коде)
- подвариантом является изменение порядка аллокации переменных на стеке
- перемещение глобала на стек и стековой переменной в глобалы
- перемещение статических данных в секцию кода .text
- xor al, al на mov al, 0 и подобные...
- изменение порядка функций и независимых секций кода (может понадобиться разбиение одного файла на несколько)
- изменение порядка независимых по данным инструкций внутри одной функции (если нету барьеров памяти)
- изменение порядка определения данных
- шифрование функций с динамической расшифровкой: поиск пролога и эпилога функций, шифрование тела, замена тела на кучу db <byte>, подстановка в пролог функции кода расшифровки

Вероятно по методам придания коду полиморфности следует использовать наработки 90-х.

Для разбора командной строки использовать реализацию getopt.c.

