module_HOWTO.txt

ПРАВИЛА РАЗРАБОТКИ МОДУЛЕЙ

Модуль представляет из себя DLL, которая будет работать в левом произвольном процессе.
На 64 битной системе будет 64-битный модуль, а на 32 битной системе 32-битный модуль.
Модуль – это не просто программа на С++. У модуля есть некоторые ограничения в связи с контекстом, в котором он работает:
1. Нужно минимизировать использование Visual C++ Runtime. Функции malloc, memcpy, str* - следует избегать. В WinAPI уже есть все необходимое – вместо malloc – HeapAlloc, вместо memcpy – CopyMemory, вместо strstr – StrStr (shlwapi.h/.lib).
1.1. STL в общем случае следует избегать. ТОЧНО не работает std::mutex. Остальное - на ваш страх и риск!
1.2. Некоторые фичи STL дают дополнительный пролог к коду. Для std::mutex он весит 200к. Его не видно в вашем коде, а он есть, и будет вести себя странно в контексте выполнения!
1.3. Несоблюдение пунктов 1 и 1.1 может быть причиной ОЧЕНЬ странного поведения.
2. Линковка рантайма и сторонних библиотек к модулю должна быть статической (флаг /MT). 
3. Если используются сторонние библиотеки, они должны позволять заменять функции управления памятью malloc/realloc/free (вместо них вы туда подсунете свои обертки над VirtualAlloc). Также они и сами должны быть слинкованы статически со всем необходимым (чтобы не было попыток загрузить какую-то dll-ку, которой по умолчанию нету в Windows).
4. Модуль может работать как от имени текущего интерактивного пользователя, так и от имени локальной системы (nt authority\SYSTEM), как НЕИНТЕРАКТИВНЫЙ процесс (как служба). По поводу неинтерактивности, гуглите Session 0 isolation/Services isolation in session 0.
5. Код модуля не должен пытаться получить путь к самому себе, ибо в реальных условиях он будет запускаться в памяти без сохранения на диск.
Разработчик обязан это учитывать, и обеспечить работу модуля во всех режимах. Игнорирование или незнание этих пунктов обычно являются причиной того, что у вас локально модуль работает, а в production – нет.
Также, есть дополнительные требования, связанные с безопасностью:
1. Запрещено использование временных файлов. По умолчанию запрещена запись в любые файлы и реестр. Каждый случай такой записи должен оговариваться.
2. Модуль по возможности не должен обладать состоянием (т.е., чтобы ему не нужно было сохранять что-либо в реестр/файл при остановке, и потом читать оттуда при запуске).
3. Если модуль работает в нескольких процессах, наилучший способ коммуникации между ними (по убыванию – помним что временные файлы запрещены):
a. Прямое чтение/запись памяти (ReadProcessMemory/WriteProcessMemory)
b. Named pipes

MODULES DEVELOPMENT RULES

The module is a DLL that will run in the left arbitrary process.
On a 64 bit system there will be a 64 bit module, and on a 32 bit system a 32 bit module.
A module is not just a C++ program. The module has some limitations due to the context in which it works:
1. Minimize the use of Visual C++ Runtime. Malloc, memcpy, str* functions should be avoided. WinAPI already has everything you need - instead of malloc - HeapAlloc, instead of memcpy - CopyMemory, instead of strstr - StrStr (shlwapi.h/.lib).
1.1. STL should generally be avoided. std::mutex DEFINITELY doesn't work. The rest is at your own peril and risk!
1.2. Some STL features provide an additional prologue to the code. For std::mutex it weighs 200k. It is not visible in your code, but it is, and will behave strangely in the execution context!
1.3. Failure to comply with points 1 and 1.1 can be the cause of VERY strange behavior.
2. Linking runtime and third-party libraries to the module must be static (/MT flag).
3. If third-party libraries are used, they should allow replacing the malloc / realloc / free memory management functions (instead of them, you slip your wrappers over VirtualAlloc there). Also, they themselves must be statically linked with everything necessary (so that there are no attempts to load some kind of dll, which is not present in Windows by default).
4. The module can work both on behalf of the current interactive user and on behalf of the local system (nt authority\SYSTEM), as a NON-INTERACTIVE process (as a service). For non-interactivity, google Session 0 isolation/Services isolation in session 0.
5. The module code should not try to get a path to itself, because in real conditions it will run in memory without being saved to disk.
The developer is obliged to take this into account and ensure the operation of the module in all modes. Ignoring or not knowing these points is usually the reason that the module works locally for you, but not in production.
Also, there are additional security-related requirements:
1. It is forbidden to use temporary files. By default, writing to any files and the registry is prohibited. Each case of such a record must be specified.
2. If possible, a module should be stateless (i.e., so that it does not need to save anything to the registry/file when it stops, and then read from there when it starts).
3. If the module works in several processes, the best way to communicate between them (in descending order - remember that temporary files are prohibited):
a. Direct Memory Read/Write (ReadProcessMemory/WriteProcessMemory)
b. Named pipes


ОФОРМЛЕНИЕ МОДУЛЯ
1. Должен иметься проект Microsoft Visual Studio версии не ниже 2015.
2. Проект Visual Studio должен быть настроен следующим образом:
* Для ВСЕХ профилей сборки:
- выходной каталог: $(SolutionDir)Bin\$(PlatformTarget)\$(Configuration)\
- Промежуточный каталог: $(SolutionDir)\obj\$(Platform)\$(Configuration)\$(ProjectName)\
- Многопроцессорная компиляция: да
* Профиль Release:
- Формат отладочной информации (С/С++ создание кода): нет
- Создавать отладочную информацию (компоновщик/отладка): нет
3. Строки обфусцировать библиотекой Andrivet (приложена, см.макрос _STR())
4. Системные вызовы обфусцировать библиотекой GetApi.h. Быть внимательным, обфускация сисвызовов может давать падения.
5. Модуль должен иметь две версии - x32- и x64-разрядную.
6. В боевой сборке должны быть обфусцированы по максимуму строки, отключен всяческий отладочный вывод.
7. Модуль должен иметь отладочную версию. Отладочный вывод должен выводиться в c:/temp/modulename.log (путь к логу настраивается в макросе).
Каждая запись лога должна содержать временнУю метку с точностью до секунды.
8. В проекте должен быть файл настроек config.h (название неважно, важна суть - здесь все глобальные настройки - пути, макросы-переключатели условной компиляции итд).
9. Модуль должен работать на всех современных версиях Windows.
   Минимальная поддерживаемая версия Windows - Windows XP (если невозможно - Windows Vista).
10. Дополнительно к компоновке должен добавляться файл notelemetry.obj (https://stackoverflow.com/questions/37761768/how-to-prevent-visual-studio-2015-update-2-to-add-telemetry-main-invoke-trigger)


MODULE DESIGN
1. You must have a Microsoft Visual Studio project of at least 2015 version.
2. The Visual Studio project must be configured as follows:
* For ALL assembly profiles:
- output directory: $(SolutionDir)Bin\$(PlatformTarget)\$(Configuration)\
- Intermediate directory: $(SolutionDir)\obj\$(Platform)\$(Configuration)\$(ProjectName)\
- Multiprocessor compilation: yes
* Release profile:
- Debug info format (C/C++ code generation): no
- Generate debug info (linker/debug): no
3. Obfuscate the strings with the Andrivet library (attached, see _STR() macro)
4. Obfuscate system calls with the GetApi.h library. Be careful, obfuscation of syscalls can cause crashes.
5. The module must have two versions - x32- and x64-bit.
6. In the combat assembly, the lines should be obfuscated to the maximum, all debugging output should be disabled.
7. The module must have a debug version. Debugging output should be displayed in c:/temp/modulename.log (the path to the log is configured in the macro).
Each log entry must contain a timestamp accurate to the second.
8. The project must have a settings file config.h (the name is not important, the essence is important - here are all the global settings - paths, conditional compilation switch macros, etc.).
9. The module should work on all modern versions of Windows.
   The minimum supported version of Windows is Windows XP (if not possible, Windows Vista).
10. Additionally, the notelemetry.obj file (https://stackoverflow.com/questions/37761768/how-to-prevent-visual-studio-2015-update-2-to-add-telemetry-main-invoke-) must be added to the layout trigger)




НАИМЕНОВАНИЕ СБОРОК

В сборке должна быть структура каталогов:

 modulename/Release_logged/x86
 modulename/Release_logged/x64
 modulename/Release_nologs/x86
 modulename/Release_nologs/x64

В Release_logged идет версия с логом и без обфускации (но это все равно профиль сборки Release!
т.е. там должны быть включены все оптимизации, выключены отладочные символы итд).
В release_nologs - версия без лога, с полной обфускацией.
В имени каталога со сборкой должно быть имя модуля и дата (например cookies.22.04.2019).
Если на указанную дату есть несколько сборок одного модуля, должен добавляться уникальный суффикс (например cookies.22.04.2019.2)

Это нужно для нормальной эксплуатации модуля - чтобы тестировщики и администраторы отличали версии сборок,
чтобы был возможно откат или апгрейд, а также для выдачи нужной сборки по её дате.


The assembly should have a directory structure:

 modulename/Release_logged/x86
 modulename/Release_logged/x64
 modulename/Release_nologs/x86
 modulename/Release_nologs/x64

Release_logged has a version with a log and no obfuscation (but it's still a Release build profile!
those. all optimizations must be enabled there, debugging symbols must be disabled, etc.).
In release_nologs - version without a log, with full obfuscation.
The name of the directory with the assembly must contain the name of the module and the date (for example, cookies.22.04.2019).
If there are several builds of the same module on the specified date, a unique suffix must be added (for example, cookies.22.04.2019.2)

This is necessary for the normal operation of the module - so that testers and administrators distinguish assembly versions,
so that a rollback or upgrade is possible, as well as for issuing the desired assembly by its date.






ТЕСТИРОВАНИЕ МОДУЛЯ

Тестировать модуль следует в следующих режимах:
1. На ОС Windows 7, 8.1, 10 как 32-, так и 64-й разрядности. В ОС НЕ должны быть установлены программы, ставящие пакеты MSVC++ runtime library (т.е., ставим голую ОС и по минимуму что нужно для тестирования).
2. От имени интерактивного юзера (того, под кем вы вошли)
3. От имени НЕ администратора
4. От имени Системы (качаем пакет pstools, запускаем модуль так: 
psexec –d –s runmodule.exe
это запуск модуля как неинтерактивный юзер SYSTEM
Только после прохождения внутренних тестов можно передавать модуль тестировщику.


MODULE TESTING

The module should be tested in the following modes:
1. On Windows 7, 8.1, 10 both 32-bit and 64-bit. Programs that install MSVC++ runtime library packages should NOT be installed in the OS (i.e., we install the bare OS and the minimum that is needed for testing).
2. On behalf of the interactive user (the one under whom you are logged in)
3. On behalf of NOT an administrator
4. On behalf of the System (download the pstools package, run the module like this:
psexec -d -s runmodule.exe
this is to run the module as a non-interactive user SYSTEM
Only after passing internal tests, you can transfer the module to the tester.








ВЗАИМОДЕЙСТВИЕ С ВЫШЕСТОЯЩЕЙ ЛОГИКОЙ

Модуль получает необходимую информацию от вышестоящей логики. Идентификатор клиента ClientID, тэг группы group, внешний IP-адрес будут переданы через функцию Start в параметре ParentInfo
Конфиги модуль получает через функцию Control (если конфигов несколько, каждому из них соответствует свое значение параметра CtlArg).
Тело конфигов и их длина будут переданы через параметры CtlArg и CtlArgLen. остальные параметры не используются.
Для автономных тестов, следует запилить демо-запускатор, который будет грузить скомпиленный модуль через loadLIbrary. Псевдокод очень примерно такой:
main() {
  LoadLibrary(“module.dll”);
  Start = GetProcAddress(module, “Start”);
  Handle = Start(…);
  If(!handle) return 1;
  Control(“config”, “config body”);
  While(true) sleep(1000);
  Release(handle);
}
Таким образом, следущая схема:
1. демо-запускатор грузит к себе модуль (DLL) и вызывает функции start и control чтобы передать в неё конфиги, внешний ip-адрес, clientid и group.
2. код внутри модуля, который делает полезную работу.

Поток выполнения следующий:
* Функция Start() инициализирует работу, запускает основной рабочий поток в фоне, и возвращает дескриптор модуля (обычно, адрес функции Start)
* Основной поток может дождаться, пока не прилетят необходимые вызовы Control() с конфигами, и только потом начать работу.
  Это зависит от назначения самого модуля - может и не требоваться ожидание.
* Вызовы Control() обычно используются, чтобы передать в модуль конфиги, либо управляющие воздействия (смена режимов работы).
  Эти вызовы должны обрабатываться как прерывания. Эти вызовы происходят в отдельном потоке, потому следует обеспечить потокобезопасность для всего,
  что разделяется с основным потоком выполнения.

  INTERACTION WITH HIGHER LOGIC

The module receives the necessary information from the higher logic. Client ID ClientID, group tag group, external IP address will be passed through the Start function in the ParentInfo parameter
The module receives configs via the Control function (if there are several configs, each of them has its own value of the CtlArg parameter).
The body of the configs and their length will be passed through the CtlArg and CtlArgLen parameters. other parameters are not used.
For standalone tests, you should write a demo launcher that will load the compiled module via loadLIbrary. The pseudocode is very similar to this:
main() {
  LoadLibrary("module.dll");
  Start = GetProcAddress(module, "Start");
  Handle = Start(…);
  If(!handle) return 1;
  Control("config", "config body");
  While(true) sleep(1000);
  release(handle);
}
So the following schema:
1. The demo launcher loads a module (DLL) and calls the start and control functions to pass configs, external ip-address, clientid and group to it.
2. code inside the module that does useful work.

The flow of execution is as follows:
* The Start() function initializes work, starts the main worker thread in the background, and returns a handle to the module (usually the address of the Start function)
* The main thread can wait until the necessary Control() calls with configs arrive, and only then start working.
  It depends on the purpose of the module itself - there may or may not be a need to wait.
* Control() calls are usually used to pass configs or control actions (change of operating modes) to the module.
  These calls must be handled as interrupts. These calls happen on a separate thread, so everything should be thread safe.
  which is shared with the main thread of execution.







API МОДУЛЯ
Модуль экспортирует следующие функции: Start, Control, Release, FreeBuffer [*1]
Все функции имеют конвенцию вызова stdcall и экспортируются по именам.
Функция Start имеет следующий прототип:
PVOID Start(
	LPCSTR ModuleName,	
	LPCBYTE Arg,
	SIZE_T ArgLen,
	LPSTR ResultInfo,
	const ParentInfo* pParentData,
	PVOID EventCallback,
	PVOID EventCallbackContext,
	PVOID Reserved1);
Функция вызывается при запуске модуля вышестоящей логикой.
ModuleName - имя модуля
Arg - аргумент команды start
ArgLen - размер параметр CtlArg в байтах
ResultInfo -буфер для результирующей строки ctl. Буфер имеет фиксированную длину 1024 байта
pParentData - информация о вышестоящей логике, управляется конфигом модуля
EventCallback – указатель на функцию логирования (см.ниже)
EventCallbackContext – контекст логирования (см.ниже)
Функция в случае удачи возвращает описатель, который необходимо использовать при вызове функций Control и Release (можно передавать адрес самой функции Start – он достаточно уникален в пределах ОС). В случае неудачи функция возвращает ноль.

typedef struct ParentInfo {
	CHAR ParentID[256];
	CHAR ParentGroup[64];
	CHAR SelfIP[64];
	LPCWSTR ParentFiles;
} ;
ParentID - полный ID клиента вышестоящей логики
ParentGroup - группирующий тег вышестоящей логики
SelfIP - внешний IP-адрес 
ParentFiles - не используется

6.2 Функция Control имеет следующий прототип
BOOL Control (
	PVOID ModuleHandle,
	LPCSTR Ctl,	
	LPCBYTE CtlArg,
	SIZE_T CtlArgLen,
	LPSTR CtlResultInfo,
	PVOID* ppOutData,
	PDWORD pOutDataSize,
	LPCSTR pOutDataTag,	
	PVOID Reserved1);

ModuleHandle - описатель модуля, которое вернула функция Start.
Ctl - строка содержащая описание управляющего сигнала к модулю
CtlArg - аргумент ctl к модулю (тело сигнала)
CtlArgLen - размер параметра CtlArg в байтах
ResultInfo -буфер для результирующей строки ctl. Буфер имеет фиксированную длину 1024 байта
ppOutData - указатель на переменную в которую будет сохранён указатель на буфер с выходными данными ctl (ctl_OutData)
pOutDataSize - указатель на переменную в которую будет сохранён размер данных в  буфере с выходными данными ctl
pOutDataTag - буфер для вспомогательного тега, который будет отправлен на сервер. Буфер имеет фиксированную длину 128 байт
Функция в случае удачи возвращает TRUE, в противном случае функция возвращает FALSE. В случае успеха если значение *ppOutData после вызова не равно нулю, то этот буфер должен быть освобождён через функцию FreeBuffer.
ОБЫЧНОЕ назначение этой функции – передача конфига модулю.

Функция Release имеет следующий прототип
VOID Release (
	PVOID ModuleHandle);
Функция реализует полное завершение работы модуля. В её задачи входит удаление всех ресурсов используемых в ходе работы модуля.

Функция FreeBuffer имеет следующий прототип
VOID FreeBuffer (
	PVOID pMemory);
Функция освобождает буфер выделенный внутри функции Control (параметр ppOutData).

* Изменения именования функций в экспорте
1) старый вариант, продолжает работать, но антивирусы часто палят модуль по этим функциям
2) Модуль экспортирует любые минимум 4 функции по именам, имена функции сообщаются администратору в виде
CheckFuncStr=Start, GetLength=Control, SetHeigth=Release, Reload=FreeBuffer.
Функции можно изменить при чистке, но опять же нужно будет сообщить об этом администратору.
3) Модуль экспортирует функции по ординалу, или по имени, но обязательно в следующем порядке: 1.Start, 2.Control, 3.FreeBuffer 4.Release
Пример def файла для экспорта по ординалам
EXPORTS
@1		= Start_
@2		= Control_
@3		= FreeBuffer_
@4		= Release_
Пример def файла для экспорта по именам:
CheckFuncStr		= Start_
GetLength		= Control_
Reload		= FreeBuffer_
SetHeigth		= Release_

ПРАВИЛА ЛОГИРОВАНИЯ СОБЫТИЙ В АДМИНКУ

Два предпоследних параметра функции Start предназначены для логирования событий в админку.
EventCallback - это указатель на функцию, определенную как:

typedef VOID (__stdcall *pEventCallback)(
	PVOID ModuleHandle,
	LPCSTR EventName,
	LPCSTR EventInfo,
	PVOID pOutData,
	DWORD OutDataSize,
	LPCSTR pOutDataTag,
	PVOID Context);

где:
	ModuleHandle - дескриптор модуля (обычно это указатель на функцию Start)
	EventName - тип события
	EventInfo - содержимое события
	pOutData - дополнительные данные события
	OutDataSize - длина доп.данных
	pOutDataTag - тэг события
	Context - передаем сюда EventCallbackContext, полученный в Start

Определяем у себя в коде функцию наподобие
void SendEvent(char* name, char* value) {
	pEventCallback callback = (pEventCallback)EvCallback;
	if (callback) {
		debug_printf("SendEvent(%s, %s)\r\n", name, value);
		callback(Start, name, value, NULL, 0, tag, EvCallbackContext);
	}
}
где
tag   - тег события (нужен для фильтрации в логах; обычно это имя модуля. Ну например, "module1")
name  - источник события (множество событий можно сгруппировать по их источнику - подсистеме в коде, где они сгенерированы. Ну например, "sql")
value - содержание события (произвольная строка. Ну например, "module1 build 01 Jan, 20xx 11:22:25 started ok")

Источник события разработчик определяет сам.
Источник должен состоять из 4 символов. К примеру, можно определить типы DEBG для отладки, VERS для передачи собственной версии, PING для передачи heartbeat'а в админку, итд.
Источник, идентифицирующий подсистему твоего модуля, из которого происходит событие. К примеру, в модуле есть подсистема работы с файлами, и подсистема сети - для них используются теги "file" и "net".
Раньше нужно было вешать мютекс на логирование, т.к. в вышестоящей логике не было защиты и проверки, и это было потоконебезопасным. Потом мютекс поставили с той стороны, и все вроде бы работает.
Но - если что - если будут проблемы - смотри в первую очередь в сторону многопоточности, во вторую очередь в конвенцию вызовов (_stdcall).

!!!!!!!!!!!
!!!ВАЖНО!!!
!!!!!!!!!!!

Событий от модуля должно быть мало и они должны быть важными. Недопустимо флудить отладкой.
т.е. ты можешь для отладки расставить в модуле логирование, но потом при выдаче сборки, ты обязан отладочные события убрать.

Отправка события является блокирующей операцией.

Следует понимать, что отправка события родителю не является мгновенной. Родитель получает события путем периодического опроса
через разделяемую память. Поэтому, хотя событие может быть отправлено, оно может быть еще не принято родителем.
Это в особенности касается событий, отправляемых перед завершением процесса - они могут быть потеряны по описанной причине.

Если модуль нерезидентный (единократно отрабатывает и далее отключается), по завершению работы он обязан отправить событие
EventName = WantRelease
EventInfo = NULL
По получению данного события носитель модуля выгрузит его из памяти.





MODULE API
The module exports the following functions: Start, Control, Release, FreeBuffer [*1]
All functions have the stdcall convention and are exported by name.
The Start function has the following prototype:
PVOID Start(
LPCSTR ModuleName,
LPCBYTE Arg,
SIZE_T ArgLen,
LPSTR ResultInfo,
const ParentInfo* pParentData,
PVOID EventCallback,
PVOID EventCallbackContext,
PVOID Reserved1);
The function is called when the module is started by the higher logic.
ModuleName - module name
Arg - start command argument
ArgLen - size of the CtlArg parameter in bytes
ResultInfo - buffer for the resulting ctl string. The buffer has a fixed length of 1024 bytes
pParentData - information about the parent logic, controlled by the module config
EventCallback - pointer to the logging function (see below)
EventCallbackContext - logging context (see below)
If successful, the function returns a descriptor that must be used when calling the Control and Release functions (you can pass the address of the Start function itself - it is quite unique within the OS). On failure, the function returns zero.

typedef struct ParentInfo {
CHAR ParentID[256];
CHAR ParentGroup[64];
CHAR SelfIP[64];
LPCWSTR ParentFiles;
} ;
ParentID - full client ID of the parent logic
ParentGroup - parent logic grouping tag
SelfIP - external IP address
ParentFiles - not used

6.2 The Control function has the following prototype
BOOL Control (
PVOID ModuleHandle,
LPCSTR Ctl,
LPCBYTE CtlArg,
SIZE_T CtlArgLen,
LPSTR CtlResultInfo,
PVOID* ppOutData,
PDWORD pOutDataSize,
LPCSTR pOutDataTag,
PVOID Reserved1);

ModuleHandle - a handle to the module returned by the Start function.
Ctl - a string containing a description of the control signal to the module
CtlArg - ctl argument to module (signal body)
CtlArgLen - size of the CtlArg parameter in bytes
ResultInfo - buffer for the resulting ctl string. The buffer has a fixed length of 1024 bytes
ppOutData - a pointer to a variable that will store a pointer to a buffer with ctl output data (ctl_OutData)
pOutDataSize - a pointer to a variable that will store the size of the data in the ctl output buffer
pOutDataTag - a buffer for an auxiliary tag to be sent to the server. The buffer has a fixed length of 128 bytes
The function returns TRUE if successful, otherwise the function returns FALSE. If successful, if the *ppOutData value after the call is not equal to zero, then this buffer must be freed via the FreeBuffer function.
The NORMAL purpose of this function is to pass a config to a module.

The Release function has the following prototype
VOID Release (
PVOID ModuleHandle);
The function implements the complete shutdown of the module. Its task is to remove all resources used during the operation of the module.

The FreeBuffer function has the following prototype
VOID FreeBuffer(
PVOID pMemory);
The function releases the buffer allocated inside the Control function (ppOutData parameter).

* Function naming changes in export
1) the old version continues to work, but antiviruses often fire the module for these functions
2) The module exports any at least 4 functions by name, the function names are reported to the administrator in the form
CheckFuncStr=Start, GetLength=Control, SetHeigth=Release, Reload=FreeBuffer.
Functions can be changed when cleaning, but again, you will need to inform the administrator about this.
3) The module exports functions by ordinal or by name, but always in the following order: 1.Start, 2.Control, 3.FreeBuffer 4.Release
An example of a def file for export by ordinals
EXPORTS
@1 = Start_
@2 = Control_
@3 = FreeBuffer_
@4 = Release_
Example def file for export by name:
CheckFuncStr = Start_
GetLength = Control_
Reload = FreeBuffer_
SetHeight = Release_

RULES FOR LOGGING EVENTS TO THE ADMIN

The two penultimate parameters of the Start function are intended for logging events to the admin panel.
EventCallback is a pointer to a function, defined as:

typedef VOID (__stdcall *pEventCallback)(
PVOID ModuleHandle,
LPCSTR EventName,
LPCSTR EventInfo,
PVOID pOutData,
DWORD OutDataSize,
LPCSTR pOutDataTag,
PVOID Context);

where:
ModuleHandle - module handle (usually a pointer to the Start function)
EventName - event type
EventInfo - event content
pOutData - additional event data
OutDataSize - length of additional data
pOutDataTag - event tag
Context - we pass here the EventCallbackContext received in Start

We define a function in our code like
void SendEvent(char* name, char* value) {
pEventCallback callback = (pEventCallback)EvCallback;
if (callback) {
debug_printf("SendEvent(%s, %s)\r\n", name, value);
callback(Start, name, value, NULL, 0, tag, EvCallbackContext);
}
}
where
tag - event tag (required for filtering in logs; usually it is the name of the module. For example, "module1")
name - the source of the event (a lot of events can be grouped by their source - the subsystem in the code where they are generated. Well, for example, "sql")
value - event content (arbitrary string. For example, "module1 build 01 Jan, 20xx 11:22:25 started ok")

The developer determines the source of the event himself.
The source must be 4 characters long. For example, you can define DEBG types for debugging, VERS for sending your own version, PING for sending heartbeat to the admin panel, etc.
A source that identifies the subsystem of your module from which the event originates. For example, the module has a subsystem for working with files, and a network subsystem - the "file" and "net" tags are used for them.
Previously, it was necessary to hang up the mutex for logging, because there was no protection and validation in the upstream logic, and it was thread-unsafe. Then the mutex was placed on the other side, and everything seems to be working.
But - if anything - if there are problems - look first of all towards multithreading, secondly to the call convention (_stdcall).

!!!!!!!!!!!
!!!IMPORTANT!!!
!!!!!!!!!!!

Events from the module should be few and important. It is unacceptable to flood debugging.
those. you can set logging in the module for debugging, but then when issuing the assembly, you must remove the debug events.

Dispatching an event is a blocking operation.

It should be understood that sending an event to the parent is not instantaneous. Parent receives events by periodically polling
through shared memory. So while the event may be dispatched, it may not yet be received by the parent.
This is especially true for events dispatched before a process terminates - they can be lost for the reason described.

If the module is non-resident (it works once and then turns off), upon completion of work, it must send an event
EventName = WantRelease
EventInfo = NULL
Upon receipt of this event, the module carrier will unload it from memory.







ТИПИЧНЫЕ ОШИБКИ

1) отправление события (сообщения), чаще всего с версией и датой модуля из функции Start.
Этого делать НЕЛЬЗЯ.
Правильно так:
- Start провел начальные проверки, инициализации, запустил основной поток и завершился
- основной поток уже начинает спамить телеметрией в событиях

2) в функцию Start передаются botid, group и ip.
эти строковые значения нужно СКОПИРОВАТЬ в функции Start, потому что при выходе из функции память строк освобождается и строки становятся невалидными.


TYPICAL ERRORS

1) sending an event (message), most often with the version and date of the module from the Start function.
Do NOT do this.
Correct like this:
- Start performed initial checks, initializations, started the main thread and ended
- the main thread is already starting to spam telemetry in events

2) botid, group and ip are passed to the Start function.
these string values need to be COPYED in the Start function, because when the function exits, the string memory is freed and the strings become invalid.
